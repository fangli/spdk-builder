diff --git a/module/bdev/aio/bdev_aio.c b/module/bdev/aio/bdev_aio.c
index 52bdbb373..955f98e9c 100644
--- a/module/bdev/aio/bdev_aio.c
+++ b/module/bdev/aio/bdev_aio.c
@@ -23,6 +23,8 @@
 
 #include <sys/eventfd.h>
 #include <libaio.h>
+#include <fcntl.h>
+#include <linux/falloc.h>
 
 struct bdev_aio_io_channel {
 	uint64_t				io_inflight;
@@ -100,7 +102,7 @@ bdev_aio_open(struct file_disk *disk)
 {
 	int fd;
 
-	fd = open(disk->filename, O_RDWR | O_DIRECT);
+	fd = open(disk->filename, O_RDWR);
 	if (fd < 0) {
 		/* Try without O_DIRECT for non-disk files */
 		fd = open(disk->filename, O_RDWR);
@@ -216,6 +218,19 @@ bdev_aio_flush(struct file_disk *fdisk, struct bdev_aio_task *aio_task)
 	}
 }
 
+static void bdev_aio_unmap(struct file_disk *fdisk, struct bdev_aio_task *aio_task,
+		uint64_t offset,
+		uint64_t byte_count)
+{
+	int rc = fallocate(fdisk->fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, offset, byte_count);
+
+	if (rc == 0) {
+		spdk_bdev_io_complete(spdk_bdev_io_from_ctx(aio_task), SPDK_BDEV_IO_STATUS_SUCCESS);
+	} else {
+		spdk_bdev_io_complete_aio_status(spdk_bdev_io_from_ctx(aio_task), -errno);
+	}
+}
+
 static void
 bdev_aio_destruct_cb(void *io_device)
 {
@@ -474,6 +489,8 @@ bdev_aio_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 static int
 _bdev_aio_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 {
+	uint32_t block_size = bdev_io->bdev->blocklen;
+
 	switch (bdev_io->type) {
 	/* Read and write operations must be performed on buffers aligned to
 	 * bdev->required_alignment. If user specified unaligned buffers,
@@ -487,7 +504,13 @@ _bdev_aio_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 		bdev_aio_flush((struct file_disk *)bdev_io->bdev->ctxt,
 			       (struct bdev_aio_task *)bdev_io->driver_ctx);
 		return 0;
-
+	case SPDK_BDEV_IO_TYPE_WRITE_ZEROES:
+	case SPDK_BDEV_IO_TYPE_UNMAP:
+		bdev_aio_unmap((struct file_disk *)bdev_io->bdev->ctxt,
+					(struct bdev_aio_task *)bdev_io->driver_ctx,
+					bdev_io->u.bdev.offset_blocks * block_size,
+					bdev_io->u.bdev.num_blocks * block_size);
+		return 0;
 	case SPDK_BDEV_IO_TYPE_RESET:
 		bdev_aio_reset((struct file_disk *)bdev_io->bdev->ctxt,
 			       (struct bdev_aio_task *)bdev_io->driver_ctx);
@@ -512,6 +535,8 @@ bdev_aio_io_type_supported(void *ctx, enum spdk_bdev_io_type io_type)
 	case SPDK_BDEV_IO_TYPE_READ:
 	case SPDK_BDEV_IO_TYPE_WRITE:
 	case SPDK_BDEV_IO_TYPE_FLUSH:
+	case SPDK_BDEV_IO_TYPE_UNMAP:
+	case SPDK_BDEV_IO_TYPE_WRITE_ZEROES:
 	case SPDK_BDEV_IO_TYPE_RESET:
 		return true;
 
